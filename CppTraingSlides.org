#+Title: C++ Training
# +Author: Prasad Ghole
#+Email: prasad.ghole@lnttechservices.com
#+REVEAL_ROOT: http://cdn.jsdelivr.net/reveal.js/3.0.0/ 
#+REVEAL_THEME: night
#+OPTIONS: toc:nil num:nil timestamp:nil 


* Introduction
C++ is a statically typed, compiled, general-purpose, case-sensitive, free-form programming language that supports procedural,
object-oriented, and generic programming paradigms.
** Standard
 | Year | C++ Standard       | Name  |
 |------+--------------------+-------|
 | 1998 | ISO/IEC 14882:1998 | C++98 |
 | 2003 | ISO/IEC 14882:2003 | C++03 |
 | 2011 | ISO/IEC 14882:2011 | C++11 |
 | 2014 | ISO/IEC 14882:2014 | C++14 |
 | 2017 | ISO/IEC 14882:2017 | C++17 |
   
* Hello World
#+BEGIN_SRC C++  :exports both :cache yes
#include <iostream>  //Used for output data to console

//Program starts here
int main()
{
     //Display this message
     //Expression
     std::cout << "Hello, world. " << std::endl;
     // Program return successfully
     return 0;
}
#+END_SRC

#+RESULTS[3167d5daadb9288017c8d213d638e12e7444d900]:
| Hello | world. |

* History
C++ was developed by Bjarne Stroustrup starting in 1979 at Bell Labs in Murray Hill, New Jersey,
as an enhancement to the C language and originally named C with Classes but later it was renamed 
C++ in 1983.
* Setup
  For windows we can download latest precompiled binaries for gcc tool chain at tdm-gcc.trdragon.org
  


* Build Tools
  gnu toolchain provide g++ command to build executable from source code.
#+BEGIN_SRC shell
g++ Program.cpp
#+END_SRC
* Popular Tools
| Tools         | Platforms              |
|---------------+------------------------|
| Visual Studio | Windows                |
| Xcode         | Mac                    |
| CodeBlock     | Windows                |
| QT Creator    | Windows, linux and Mac |
|               |                        |

* Build Process
** Compiling
#+BEGIN_SRC shell :exports code
g++ --std=c++y hello.cpp -o hello.cpp
#+END_SRC

#+RESULTS:
| Microsoft                           | Windows | [Version  | 10.0.16299.785] |     |        |           |
| (c)                                 |    2017 | Microsoft | Corporation.    | All | rights | reserved. |
|                                     |         |           |                 |     |        |           |
| c:\Users\20006401\cpptraining>More? |         |           |                 |     |        |           |

** Linking

Converting C++ source code in machine language which can be exectured by underline microprocessor
is called as build process.
* Language Features
1. Statically typed
2. Support procedural , object oriented and generic programming paradigms
3. Compiled
4. Versatile standard library
5. Encapsulation
6. Inheritance
7. Polymorphism 

* Literals
Literals are tokens of C++ program that represent constant values embedded in source code.
*** Interger Literals
| Literal     | Desctiption                                                       |  Example |
|-------------+-------------------------------------------------------------------+----------|
| Decimal     | non zero decimal digit followed by zero or more significant digit |       42 |
| Octal       | digit zero followed by zero or more octal digits (0-7)            |      052 |
| Hexadecimal | character sequence 0x or 0X followed by hex digits (0-9 , a-f)    |     0x2a |
| binary      | character sequence 0b or 0B followed by binary digits (0,1)       | 0b101010 |

Since 2014 you can use optinal single quotes (') as a serperator.
Following variables are initialized for same values
#+BEGIN_SRC C++ :exports code :eval no
unsigned long long l1 = 18446744073709550592ull; // C++11
unsigned long long l2 = 18'446'744'073'709'550'592llu; // C++14
unsigned long long l3 = 1844'6744'0737'0955'0592uLL; // C++14
unsigned long long l4 = 184467'440737'0'95505'92LLU; // C++14
#+END_SRC

Hexadecimal literals ending in e or E followed by + or - must be seperated from operator with white space.
#+BEGIN_SRC C++ :exports code :eval no
auto x = 0xE+2.0;   // error
auto y = 0xa+2.0;   // OK
auto z = 0xE +2.0;  // OK
auto q = (0xE)+2.0; // OK
#+END_SRC
*** Integer suffix
    u or U unsigned suffix
    ll or LL long long suffix
#+BEGIN_SRC C++ :exports both :cache yes

#include <iostream> 
int main() 
{
std::cout << "sizeof(123u) " << sizeof(123u) << std::endl;
std::cout << "sizeof(123ul) " << sizeof(123ul) << std::endl;
std::cout << "sizeof(123ull) " << sizeof(123ull) << std::endl;
} 

#+END_SRC

#+RESULTS[2cfde06023a5646abe0954ea11a40a6b81af5906]:
| sizeof(123u)   | 4 |
| sizeof(123ul)  | 4 |
| sizeof(123ull) | 8 |

# https://en.cppreference.com/w/cpp/language/integer_literal 
** Variable Type
 | Category  | Type                      | Meaning       | Example |   |
 |-----------+---------------------------+---------------+---------+---|
 | boolean   | bool                      | true or false |         |   |
 | Character | char                      |               |         |   |
 | Integer   | short,int,long,long long  |               |         |   |
 | floating  | float, double,long double |               |         |   |
 | void      | no type                   |               |         |   |
** bool 
#+BEGIN_SRC C++  :exports both :cache yes
#include <iostream> 
int main() 
{
std::cout << std::boolalpha << true << std::endl; 
std::cout << std::boolalpha << false << std::endl;
 std::cout << std::noboolalpha << true << std::endl;
 std::cout << std::noboolalpha << false << std::endl;
} 
#+END_SRC 

#+RESULTS[761dc02922fa049315904bec55f4709d19fa6a39]:
|  true |
| false |
|     1 |
|     0 |
** Variable initialization
#+BEGIN_SRC C++
int Number_of_Employee = 100;
//Uniform initialization
int Number_Of_Employee = {100};
#+END_SRC
** Signed integer Data Types
| Type        | Size | Range                                       |
|-------------+------+---------------------------------------------|
| signed char |    1 | -128 to 127                                 |
| short       |    2 | -256 to 255                                 |
| signed int  |    4 | -2147483648 to 2147483647                   |
| long int    |    8 | -9223372036854775808 to 9223372036854775807 |

** Signed and Unsigned 
Below example shows behaviour when signed and unsigned values are mixed.
#+BEGIN_SRC C++  :exports both :cache yes
#include <iostream> 
int main() 
{
unsigned u = 20;
int i = -42;

std::cout << i + i << std::endl;;
std::cout << u + i << std::endl;
} 
#+END_SRC 

#+RESULTS[32d1f3894007c02aac1578f090e38ec6cf803d2e]:
|        -84 |
| 4294967274 |

# C++ Primer 2.1.2
*** Activity 1
What will be output of this code ?
 #+BEGIN_SRC C++ :exports code :eval yes

#include <iostream> 
int main() 
{
  for(signed int i = 10; i >= 0 ; i++)
  {
  std::cout << i << std::endl;
  } 
}
 
 #+END_SRC

# C++ Primer 2.1.2
** Varible with fixed values
** Integer Literals 
** Floating point Literals
** Character Literals
** Sting Literals
** Sizeof operator
Is used to obtain the number of bytes occupied by the type, variable or result of an expression.

   
* Variables and Fundamental Data Types
A variable is a named piece of memory a programmer defines.
Every variable has a type which defines what kind of data it can store.

* Complex Data Structure
** Array
** String
** Structure
** Unions
** Enumerations

* Flow Control
** if
** while
** for
** switch
* Operators
** Arithmetic
| Operations     | Operators | C++        |
|----------------+-----------+------------|
| Addition       | +         | count + 10 |
| Subtraction    | -         | count - 10 |
| Multiplication | *         | count * 10 |
| Division       | /         | count / 10 |
| Reminder       | %         | count % 10 |

Interger division always produce integer output for eg.
#+BEGIN_SRC C++ :exports both :cache yes
#include <iostream>  //Used for output data to console

int main()
{
std::cout << "Division 7/2 = " << 7/2 << std::endl;
std::cout << "Reminder 7%2 = " << 7%2 << std::endl;
return 0;
}
#+END_SRC

#+RESULTS[188f91238c931739ca08b4491379a49494ca84e8]:
| Division | 7/2 | = | 3 |
| Reminder | 7%2 | = | 1 |

*** Prcedence of arithmetic operators
| Operator | order of evluation                      |
|----------+-----------------------------------------|
| ()       | Evaluated first.                        |
| * /  %   | Evaluated second in left to right order |
| +  -     | Evaluated last in left to right order   |
** Increament and Decreament 
*** Postfix Increament
#+BEGIN_SRC C++ :exports both :cache yes
  #include <iostream> 
  int main() 
  {
     int total = 0;
     int count = 5;
    std::cout << "count\t" << count << std::endl << "total\t" << total << std::endl ;
    count = total++  + 20; 
    std::cout << "count\t" << count << std::endl << "total\t" << total  << std::endl;
    }
#+END_SRC

#+RESULTS[ccbe36bc80a25a3157d2e5a95e313481927fbe4e]:
| count |  5 |
| total |  0 |
| count | 20 |
| total |  1 |

*** Prefix Increament
#+BEGIN_SRC C++ :exports both :cache yes
  #include <iostream> 
  int main() 
  {
     int total = 0;
     int count = 5;
    std::cout << "count\t" << count << std::endl << "total\t" << total << std::endl ;
    count = ++total+ 20; 
    std::cout << "count\t" << count << std::endl << "total\t" << total  << std::endl;
    }
#+END_SRC

#+RESULTS[b899901a7ea31195efe4334aca07f5f03a93e3e9]:
| count |  5 |
| total |  0 |
| count | 21 |
| total |  1 |


** Comparison
For various logical condition checking we need to compare to variables using comparison operator.
| Operator | Sample | Meaning                    |
|----------+--------+----------------------------|
| >        | x > y  | x is greater than y        |
| <        | x < y  | x is less than y           |
| >=       | x >= y | x is greater or equal to y |
| <=       | x <=y  | x is less or equal to y    |
| ==       | x == y | if x is equal to y         |
| !=       | x != y | if x is not equal to y     |

Reversing order of operators may cause complier to emit syntax error. But some operator like != when 
written like =! will be logical error.
Also equality operator == when written like = will be logical error.
*** Prcedence of comparison operators
| Operator  | order of evluation                      |
|-----------+-----------------------------------------|
| ()        | Evaluated first.                        |
| * /  %    | Evaluated second in left to right order |
| << >>     |                                         |
| < <= > >= |                                         |
| == !=     |                                         |
| =         |                                         |

** Bitwise
These operators allowes to manuplate individual bits of integer type variables.
| operation        | Operator  |
|------------------+-----------|
| One's complement | ~x        |
| left shift       | x << y    |
| right shift      | x >> y    |
| Bitwise and      | x & y     |
| Bitwise or       | x \vert y |
| Bitwise Xor      | x ^y      |


* Iteration

* Functions
** Prototype
** Parameters
** inline 
** Storage classes and scope

* Header Files
* Pointers 
* Reference 
  A referance is an alternate name for variable or object. All referance must be initialized. All operations performed 
on refernces act on binded variable or object.
#+BEGIN_SRC C++ :eval no 
int original_var = 10;
int &ref_var = original_var;
int &ref_lit = 100; //Error can't refer to literal constant
float &fref_var = original_var;  // Reference should be of same type

#+END_SRC
* Array
* struct
* enumerations 
* Classes and Objects
* Constructor
* copy constructor
* Destructor
* Member initializer list
* Inheritance 
* Interfaces
* const
* mutable
* operator overloading 
* this keyword
* object lifetime
* auto keyword 
* Namespaces 
* Unions
* Why virtual destructors
* Casting
