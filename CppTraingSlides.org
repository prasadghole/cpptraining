#+Title: C++ Training
# +Author: Prasad Ghole
#+Email: prasad.ghole@lnttechservices.com
#+REVEAL_ROOT: http://cdn.jsdelivr.net/reveal.js/3.0.0/ 
#+REVEAL_THEME: night
#+OPTIONS: toc:nil num:nil timestamp:nil 


* Introduction
C++ is a statically typed, compiled, general-purpose, case-sensitive, free-form programming language that supports procedural,
object-oriented, and generic programming paradigms.
** Standard
 | Year | C++ Standard       | Name  |
 |------+--------------------+-------|
 | 1998 | ISO/IEC 14882:1998 | C++98 |
 | 2003 | ISO/IEC 14882:2003 | C++03 |
 | 2011 | ISO/IEC 14882:2011 | C++11 |
 | 2014 | ISO/IEC 14882:2014 | C++14 |
 | 2017 | ISO/IEC 14882:2017 | C++17 |
   
* Hello World
#+BEGIN_SRC C++  :exports both :cache yes
#include <iostream>  //Used for output data to console

//Program starts here
int main()
{
     //Display this message
     //Expression
     std::cout << "Hello, world. " << std::endl;
     // Program return successfully
     return 0;
}
#+END_SRC

#+RESULTS[3167d5daadb9288017c8d213d638e12e7444d900]:
| Hello | world. |

* History
C++ was developed by Bjarne Stroustrup starting in 1979 at Bell Labs in Murray Hill, New Jersey,
as an enhancement to the C language and originally named C with Classes but later it was renamed 
C++ in 1983.
* Setup
  For windows we can download latest precompiled binaries for gcc tool chain at tdm-gcc.trdragon.org
  


* Build Tools
  gnu toolchain provide g++ command to build executable from source code.
#+BEGIN_SRC shell
g++ Program.cpp
#+END_SRC
* Popular Tools
| Tools         | Platforms              |
|---------------+------------------------|
| Visual Studio | Windows                |
| Xcode         | Mac                    |
| CodeBlock     | Windows                |
| QT Creator    | Windows, linux and Mac |
|               |                        |

* Build Process
** Compiling
#+BEGIN_SRC shell :exports code
g++ --std=c++y hello.cpp -o hello.cpp
#+END_SRC

#+RESULTS:
| Microsoft                           | Windows | [Version  | 10.0.16299.785] |     |        |           |
| (c)                                 |    2017 | Microsoft | Corporation.    | All | rights | reserved. |
|                                     |         |           |                 |     |        |           |
| c:\Users\20006401\cpptraining>More? |         |           |                 |     |        |           |

** Linking

Converting C++ source code in machine language which can be exectured by underline microprocessor
is called as build process.
* Language Features
1. Statically typed
2. Support procedural , object oriented and generic programming paradigms
3. Compiled
4. Versatile standard library
5. Encapsulation
6. Inheritance
7. Polymorphism 

* Literals
Literals are tokens of C++ program that represent constant values embedded in source code.
*** Interger Literals
| Literal     | Desctiption                                                       |  Example |
|-------------+-------------------------------------------------------------------+----------|
| Decimal     | non zero decimal digit followed by zero or more significant digit |       42 |
| Octal       | digit zero followed by zero or more octal digits (0-7)            |      052 |
| Hexadecimal | character sequence 0x or 0X followed by hex digits (0-9 , a-f)    |     0x2a |
| binary      | character sequence 0b or 0B followed by binary digits (0,1)       | 0b101010 |

Since 2014 you can use optinal single quotes (') as a serperator.
Following variables are initialized for same values
#+BEGIN_SRC C++ :exports code :eval no
unsigned long long l1 = 18446744073709550592ull; // C++11
unsigned long long l2 = 18'446'744'073'709'550'592llu; // C++14
unsigned long long l3 = 1844'6744'0737'0955'0592uLL; // C++14
unsigned long long l4 = 184467'440737'0'95505'92LLU; // C++14
#+END_SRC

Hexadecimal literals ending in e or E followed by + or - must be seperated from operator with white space.
#+BEGIN_SRC C++ :exports code :eval no
auto x = 0xE+2.0;   // error
auto y = 0xa+2.0;   // OK
auto z = 0xE +2.0;  // OK
auto q = (0xE)+2.0; // OK
#+END_SRC
*** Integer suffix
    u or U unsigned suffix
    ll or LL long long suffix
#+BEGIN_SRC C++ :exports both :cache yes

#include <iostream> 
int main() 
{
std::cout << "sizeof(123u) " << sizeof(123u) << std::endl;
std::cout << "sizeof(123ul) " << sizeof(123ul) << std::endl;
std::cout << "sizeof(123ull) " << sizeof(123ull) << std::endl;
} 

#+END_SRC

#+RESULTS[2cfde06023a5646abe0954ea11a40a6b81af5906]:
| sizeof(123u)   | 4 |
| sizeof(123ul)  | 4 |
| sizeof(123ull) | 8 |

# https://en.cppreference.com/w/cpp/language/integer_literal 
** Variable Type
 | Category  | Type                      | Meaning       | Example |   |
 |-----------+---------------------------+---------------+---------+---|
 | boolean   | bool                      | true or false |         |   |
 | Character | char                      |               |         |   |
 | Integer   | short,int,long,long long  |               |         |   |
 | floating  | float, double,long double |               |         |   |
 | void      | no type                   |               |         |   |
** bool 
#+BEGIN_SRC C++  :exports both :cache yes
#include <iostream> 
int main() 
{
std::cout << std::boolalpha << true << std::endl; 
std::cout << std::boolalpha << false << std::endl;
 std::cout << std::noboolalpha << true << std::endl;
 std::cout << std::noboolalpha << false << std::endl;
} 
#+END_SRC 

#+RESULTS[761dc02922fa049315904bec55f4709d19fa6a39]:
|  true |
| false |
|     1 |
|     0 |
** Variable initialization
#+BEGIN_SRC C++
int Number_of_Employee = 100;
//Uniform initialization
int Number_Of_Employee = {100};
#+END_SRC
** Signed integer Data Types
| Type        | Size | Range                                       |
|-------------+------+---------------------------------------------|
| signed char |    1 | -128 to 127                                 |
| short       |    2 | -256 to 255                                 |
| signed int  |    4 | -2147483648 to 2147483647                   |
| long int    |    8 | -9223372036854775808 to 9223372036854775807 |

** Signed and Unsigned 
Below example shows behaviour when signed and unsigned values are mixed.
#+BEGIN_SRC C++  :exports both :cache yes
#include <iostream> 
int main() 
{
unsigned u = 20;
int i = -42;

std::cout << i + i << std::endl;;
std::cout << u + i << std::endl;
} 
#+END_SRC 

#+RESULTS[32d1f3894007c02aac1578f090e38ec6cf803d2e]:
|        -84 |
| 4294967274 |

# C++ Primer 2.1.2
*** Activity 1
What will be output of this code ?
 #+BEGIN_SRC C++ :exports code :eval yes

#include <iostream> 
int main() 
{
  for(signed int i = 10; i >= 0 ; i++)
  {
  std::cout << i << std::endl;
  } 
}
 
 #+END_SRC

# C++ Primer 2.1.2
** Varible with fixed values
** Integer Literals 
** Floating point Literals
** Character Literals
** Sting Literals
** Sizeof operator
Is used to obtain the number of bytes occupied by the type, variable or result of an expression.

   
* Variables and Fundamental Data Types
A variable is a named piece of memory a programmer defines.
Every variable has a type which defines what kind of data it can store.

* Complex Data Structure
** Array
** String
** Structure
** Unions
** Enumerations

* Flow Control
** if
** while
** for
** switch
* Operators
** Arithmetic
| Operations     | Operators | C++        |
|----------------+-----------+------------|
| Addition       | +         | count + 10 |
| Subtraction    | -         | count - 10 |
| Multiplication | *         | count * 10 |
| Division       | /         | count / 10 |
| Reminder       | %         | count % 10 |

Interger division always produce integer output for eg.
#+BEGIN_SRC C++ :exports both :cache yes
#include <iostream>  //Used for output data to console

int main()
{
std::cout << "Division 7/2 = " << 7/2 << std::endl;
std::cout << "Reminder 7%2 = " << 7%2 << std::endl;
return 0;
}
#+END_SRC

#+RESULTS[188f91238c931739ca08b4491379a49494ca84e8]:
| Division | 7/2 | = | 3 |
| Reminder | 7%2 | = | 1 |

*** Prcedence of arithmetic operators
| Operator | order of evluation                      |
|----------+-----------------------------------------|
| ()       | Evaluated first.                        |
| * /  %   | Evaluated second in left to right order |
| +  -     | Evaluated last in left to right order   |
** Increament and Decreament 
*** Postfix Increament
#+BEGIN_SRC C++ :exports both :cache yes
  #include <iostream> 
  int main() 
  {
     int total = 0;
     int count = 5;
    std::cout << "count\t" << count << std::endl << "total\t" << total << std::endl ;
    count = total++  + 20; 
    std::cout << "count\t" << count << std::endl << "total\t" << total  << std::endl;
    }
#+END_SRC

#+RESULTS[ccbe36bc80a25a3157d2e5a95e313481927fbe4e]:
| count |  5 |
| total |  0 |
| count | 20 |
| total |  1 |

*** Prefix Increament
#+BEGIN_SRC C++ :exports both :cache yes
  #include <iostream> 
  int main() 
  {
     int total = 0;
     int count = 5;
    std::cout << "count\t" << count << std::endl << "total\t" << total << std::endl ;
    count = ++total+ 20; 
    std::cout << "count\t" << count << std::endl << "total\t" << total  << std::endl;
    }
#+END_SRC

#+RESULTS[b899901a7ea31195efe4334aca07f5f03a93e3e9]:
| count |  5 |
| total |  0 |
| count | 21 |
| total |  1 |


** Comparison
For various logical condition checking we need to compare to variables using comparison operator.
| Operator | Sample | Meaning                    |
|----------+--------+----------------------------|
| >        | x > y  | x is greater than y        |
| <        | x < y  | x is less than y           |
| >=       | x >= y | x is greater or equal to y |
| <=       | x <=y  | x is less or equal to y    |
| ==       | x == y | if x is equal to y         |
| !=       | x != y | if x is not equal to y     |

Reversing order of operators may cause complier to emit syntax error. But some operator like != when 
written like =! will be logical error.
Also equality operator == when written like = will be logical error.
*** Prcedence of comparison operators
| Operator  | order of evluation                      |
|-----------+-----------------------------------------|
| ()        | Evaluated first.                        |
| * /  %    | Evaluated second in left to right order |
| << >>     |                                         |
| < <= > >= |                                         |
| == !=     |                                         |
| =         |                                         |

** Bitwise
These operators allowes to manuplate individual bits of integer type variables.
| operation        | Operator  |
|------------------+-----------|
| One's complement | ~x        |
| left shift       | x << y    |
| right shift      | x >> y    |
| Bitwise and      | x & y     |
| Bitwise or       | x \vert y |
| Bitwise Xor      | x ^y      |


* Iteration

* Functions
** Prototype
** Parameters
** inline 
** Storage classes and scope

* Header Files
* Reference 
  A referance is an alternate name for variable or object. All referance must be initialized. All operations performed 
on refernces act on binded variable or object.
#+BEGIN_SRC C++ :eval no 
int original_var = 10;
int &ref_var = original_var;
int &ref_lit = 100; //Error can't refer to literal constant
float &fref_var = original_var;  // Reference should be of same type

#+END_SRC
* Pointers 
** references to pointers
A reference is not an object hence we may not have pointers to references but we can have reference to pointer.
#+BEGIN_SRC C++ :exports both :cache yes
#include <iostream>
int main()
{

int i = 100;
int *iptr = &i;
int *&iptrref = iptr;

std::cout << "Value of i =\t " << i << std::endl ;
std::cout << "Value of i using poiner iptr =\t " << *iptr << std::endl ;
std::cout << "Value of i using reference to pointer =\t " << *iptrref << std::endl ;
}

#+END_SRC

#+RESULTS[3445f968a3e13c9130866007256095b7a72fcc32]:
| Value of i =                            | 100 |
| Value of i using poiner iptr =          | 100 |
| Value of i using reference to pointer = | 100 |

* Array
* struct
* enumerations 
* Classes and Object
Object is any real world entity which has attributes, behaviour , state and identity.
Compared to object is template or blueprint of object from which many objects can be created. 
object is an instance of a class. 
* Constructor
* copy constructor
* Destructor
* Member initializer list
* Inheritance 
* Interfaces
* const qualifier 
const qualified variable value can't be changed. Because we can't change the value of const 
variable it must be initialized when we create it.

#+BEGIN_SRC C++ :eval no :cache yes
const int buffersize = 100;
buffersize = 200 ; //ERROR can't change the value
const int length; //ERROR must be initialize 
#+END_SRC
** const objects scope
   By default all the const objects have local scope. Hence when we split program in multiple files.
Every file that uses const must have initialzer which can have different value 

In order to have single instance of const object shared across multiple file we should use qualifier *extern* 
in both definition and declarations 
#+BEGIN_SRC C++ :eval no :caches yes
//.CPP file definition
extern const buffersize = 20;
//.h file declarations
extern const buffersize;
#+END_SRC

** Reference to cost
Reference to constant object can't be used to change object to which it refers to.
#+BEGIN_SRC C++ :eval no :cache yes
#include <iostream>

int main()
{
const int cint = 100;
const int &refcint = cint;
int &refint = cint; //ERROR can't have non const reference to const objects
}

#+END_SRC
We can initialize a reference to const from any expression that can be converted to type of reference.
We can bind reference to *const* to *nonconst* object or literal or expression.

#+BEGIN_SRC C++ :cache yes

#include <iostream>

int main()
{

int i = 42;

const int &r1 = i;
const int &r2 = 43; // OK reference to const 
const int &r3 = r1 * 2;

std::cout << "r1 \t " << r1 << std::endl;
std::cout << "r2 \t " << r2 << std::endl;
std::cout << "r3 \t " << r3 << std::endl;

//int &r4 = 43; //ERROR non const reference to constant
} 

#+END_SRC

#+RESULTS[263f6003f9aa474164f593473f1c01b354089ac7]:
| r1 | 42 |
| r2 | 43 |
| r3 | 84 |

* mutable
* operator overloading 
* this keyword
* object lifetime
* auto keyword 
* Namespaces 
* Unions
* Why virtual destructors
* Casting
